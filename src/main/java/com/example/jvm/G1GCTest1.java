package com.example.jvm;

/**
 * 吞吐量
 *  1. 吞吐量关注的是在一个指定的时间内，最大化一个应用的工作量。
 *  2. 如下方式来衡量一个系统吞吐量的好坏：
 *      （1）.在一个小时内同一个事务（任务、请求）完成的次数（qps）
 *      （2）.数据库一小时可以完成多少次查询
 *  3. 对于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力，单次快速的响应并不值得考虑。
 *
 * 响应能力
 *  1. 响应能力指一个程序或者系统对请求是否能够及时相应，比如： 一个桌面UI能多快的相应一个事件；一个网站能够多快返回一个页面请求；数据库能够多快返回查询的数据...
 *  2. 对于这类响应能力敏感的场景，长时间的停顿是无法接受的。
 */

/**
 * G1 Garbage Collector
 *  1. G1收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。
 *  2. G1满足短时间GC停顿的同事达到一个较高的吞吐量。
 *  3. JDK1.7 以上版本适用。
 *
 * G1收集器的设计目标
 *  1. 与应用线程同时工作，几乎不需要STW（与CMS类似）。
 *  2. 整理剩余空间，不产生内存碎片（CMS只能在Full GC时， 用STW整理内存碎片）
 *  2. GC停顿更加可控。
 *  3. 不牺牲系统的吞吐量。
 *  4. GC 不要求额外的内存空间（CMS需要预留空间存储浮动垃圾）。
 *
 * G1收集器堆结构
 *  1. heap被划分为一个个相等的不连续的内存区域（regions），每个region都有一个分代的角色： Eden、Survivor、Old。
 *  2. 对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化。
 *  3. G1最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域（region）
 *  4. G1使用了GC停顿可以测的模型，来满足用户设定的GC停顿时间，根据用户设定的目标时间，G1会自动的选择哪些region要清除，一次清除多少个region。
 *  5. G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存（copying收集算法）
 */

/**
 * G1 VS CMS
 *  1. 对比使用 Mark-Sweep的CMS，G1使用的复制算法不会造成内存碎片。
 *  2. 对比Parallel Scavenge（基于复制算法）、Parallel Old收集器（基于标记整理算法），Parallel会对整个区域做整理导致GC停顿会比较长，而G1只是特定的整理几个region。
 *  3. G1并非一个实时的收集器，与Parallel Scavenge一样，对GC停顿时间的设置并不绝对生效，只是G1有较高的几率保证不超过设定的GC停顿时间。与之前的GC收集器对比，
 *      G1会根据用户设定的GC停顿时间，智能评估哪几个region需要被回收可以满足用户的设定。
 *  4. G1相对于CMS的优势：
 *      （1）.G1在压缩空间方面有优势；
 *      （2）.G1通过将内存空间分成区域的方式避免了内存碎片问题；
 *      （3）.Eden、Survivor、Old区不在固定，在内存使用效率上来说更灵活。
 *      （4）.G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间，避免应用雪崩现象；
 *      （5）.G1在回收内存后会同时做合并空闲内存的工作，而CMS默认是在STW的时候做；
 *      （6）.G1会在Young GC中使用，而CMS只能在Old区使用；
 */

/**
 * G1重要的概念
 *  1. 分区（region）： G1采用了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控等问题。G1将整个堆分成相同大小的分区。
 *  2. 每个分区都可能是年轻代也可能是老年代，但是在同一个时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，
 *      这些方便复用之前分代框架的逻辑。
 *  3. 在物理上不需要连续，则带来了额外的好处————有的分区内垃圾对象特别多，有的分区内垃圾对象很少，G1会优先回收垃圾对象特别多的分区，
 *      这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即首先垃圾最多的分区
 *  4. 依然是在新生代满了的时候，对整个新生代进行回收————整个新生代中的对象，要么被回收、要么晋升，至于新生代也采取分区机制的原因，
 *      则是因为这样跟老年代的策略统一，方便调整代的大小。
 *  5. G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩。
 *  6. 收集集合（CSet）： 一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden空间、
 *                      Survivor空间、老年代。
 *  7. 已记忆集合（RSet）： RSet记录了其它Region中的对象引用本Region中对象的关系，属于point-into结构（谁引用了我的对象）。RSet的
 *                          价值在于是的垃圾收集器不需要扫描整个堆来找到谁引用了当前分区中的对象，只需要扫描RSet即可。
 *                          在CMS中，也有RSet的概念，在老年代中有一块区域用来记录执行新生代的引用。这是一种 point-out，在进行 Young GC时，
 *                          扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。
 *  8. G1 GC是在points-out的card table之上再加了一层结构来构成points-into RSet: 每个region会记录下到底哪些别的region有指向自己
 *      的指针，而这些指针分别在哪些card的范围内。
 *  9. 这个RSet其实一个hash table，key是别的region的起始地址，value是一个集合，里面的元素是card table的index。举例来说，如果
 *      regionA的Rest里有一项的key是regionB，value里有index为1234的card，它的意思就是regionB的一个card里有引用指向regionA。
 *      所以对regionA来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。
 *  10. Snapshot-At-The-Beginning（SATB）： SATB是G1 GC在并发标记阶段使用的增量式的标记算法。
 *  11. 并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区。
 *
 * G1的适合场景：
 *  1. 服务端多核CPU、JVM内存占用较大的应用。
 *  2. 应用在运行过程中会产生大量内存碎片、需要经常压缩空间
 *  3. 想要更可控、可预期的GC停顿周期；防止高并发下应用的雪崩现象。
 *
 * G1 GC 模式
 *  1. G1提供了两种GC模式，Young GC 和 Mixed GC，两种都是完全 STW的。
 *  2. Young GC：
 *      （1）.选定所有年轻代里的Region。通过控制年轻代的Region个数，即年轻代内存大小，来控制Young GC的时间开销。
 *      （2）.Young GC 主要是对Eden 区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果
 *            Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。
 *      （3）.Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC完成工作，应用线程继续执行。
 *      （4）.在G1中，并没有用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的
 *              分区引用也扫描了。
 *      （5）.G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样将这些对象当做根来扫描，避免了无效的扫描。新生代
 *              有很多个，没必要在新生代之间记录引用，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。
 *              需要注意的是，如果引用的对象（老年代的对象）很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1中有引入了
 *              另一个概念————卡表（Card Table）。一个卡表将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常非常小，介于
 *              128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来表示每个分区的空间地址。每个元素对应着堆内存的一块
 *              区域是否存在跨代引用的对象，当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为 ‘dirty’。此外，RSet也将这个数组
 *              下标记录下来。一般情况，这个RSet其实是一个Hash Table ,key 是别的Region的其实地址，value是一个集合，里面的元素是Card Table
 *              的index。
 *  3. Mixed GC：
 *      （1）.选定所有年轻代里的Region，外加根据 global concurrent marking 统计得出收益集收益高的若干个老年代Region。在用户指定的开销目标
 *              范围内尽可能选择收益高的老年代Region。
 *      （2）.Mixed GC不仅进行 正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。
 *
 *  4. Mixed GC不是Full GC，它只能回收部分老年代的Region，如果Mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续
 *      进行Mixed GC，就会使用 serial old GC（Full GC） 来收集这个GC Heap。
 *
 * GC 回收阶段
 *  1. G1 Young
 *      （1）.根扫描： 静态和本地对象被扫描
 *      （2）.更新RS： 处理dirty card队列更新RS
 *      （3）. 处理RS： 检测从年轻代指向老年代的对象
 *      （4）. 对象拷贝： 拷贝存活的对象到 survivor/old 区域
 *      （5）. 处理引用队列： 软引用、弱引用、虚引用处理。
 *  2. Mixed GC
 *      （1）.全局并发标记（global concurrent marking）
 *      （2）.拷贝存活对象（evacuation）
 *
 * global concurrent marking
 *  1. global concurrent marking的执行过程类似于 CMS，但是不同的是在G1 GC它主要是为 Mixed GC提供标记服务的，并不是一次GC过程的一个必要环节。
 *  2. global concurrent marking的执行过程分四个步骤：
 *      （1）.初始标记(initial mark,STW): 它标记了从GC Root开始直接可达的对象。此阶段共用了Young GC的暂停，这是因为他们可以复用root scan操作，
 *                                          所以可以说 global concurrent marking 是伴随 Young GC而发生的。
 *      （2）.并发标记(concurrent marking): 这个阶段从 GC Root 开始对 Heap 中的兑现进行标记，标记线程与应用线程并发执行，并且收集各个Region的存活信息。
 *      （3）.重新标记(Remark,STW): 标记那些在并发阶段发生变化的对象，将被回收。
 *      （4）.清理(Cleanup): 清除空Region（没有存活对象的），加入到free list。 Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。
 *
 * G1在运行过程中的主要模式
 *  1. Young GC（不用于CMS）
 *  2. 并发阶段
 *  3. 混合阶段
 *  4. Full GC（一般是G1出现问题是发生的）
 *
 * G1 GC触发时机
 *  1. Young GC： 在 Eden充满时触发，在回收之后所有之前属于 Eden 的区块全部变成空白，既不属于任何一个分区（Eden、Survivor、Old）
 *  2. Mixed GC： 由一些参数控制，另外也控制着那些老年代Region会被选入CSet（收集集合）。
 *      （1）.G1HeapWastePercent: 在 global concurrent marking 结束之后，我们可以知道 old generation regions中有多少空间要被回收，
 *              在每次Young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。
 *      （2）.G1MixedGCLiveThresholdPercent: old generation region 中的存活对象的占比，只有在此参数之下，才会被选入CSet。
 *      （3）.G1MixedCGCountTarget: 一次 global concurrent marking 之后，最多执行 mixed GC 的次数。
 *      （4）.G1OldCSetRegionThresholdPercent: 一次Mixed GC中能被选入CSet的最多 old generation region数量。
 *
 * G1收集概览
 *  1. G1 算法将堆划分为若干个区域,它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，
 *      将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另一个区域，完成了清理工作。这就意味着
 *      在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片问题的存在了。
 *
 * Humongous区域
 *  1. 在G1中，还有一种特殊的区域，叫Humongous区域。如果一个对象占用的空间达到或是超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些
 *      巨型对象，默认直接会被分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个
 *      Humongous 区，它用来专门存放巨型对象。如果一个 Humongous 区装不下一个巨型对象，那么G1会寻找连续的 Humongous 分区来存储。为了能
 *      找到连续的 Humongous 区，有时候不得不启动 Full GC。
 */

/**
 * 三色标记算法
 *  1. 他是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性。
 *  2. 三色标记算法将对象分成三种类型：
 *      （1）.黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且他的所有field也被标记完了）。
 *      （2）.灰色：对象本身被扫描，但还没有扫描完该对象中的子对象（它的field还没有被标记或标记完）。
 *      （3）.未被扫描的对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象（对象没有被标记到）。
 *  3. 根对象被置为黑色，子对象被置为灰色。继续由黑色遍历，将已扫描子对象的对象置为黑色。
 *  4. 遍历所有可达的对象后，所有可达对象都将变成黑色，不可达的对象即为白色，需要被清理。
 *  5. 在G1中，使用的是SATB的方式，删除的时候记录它所有的对象。
 *  6. 三色标记三步骤：
 *      （1）.在开始标记的时候生成一个快照图，标记存活对象。
 *      （2）.在并发标记的时候所有被改变的对象入队列（在写屏障(write barrier)里把所有旧的引用所指向的对象都变成非白的）
 *      （3）.可能存在浮动垃圾，将在下次被收集。
 *
 * SATB（Snapshot-At-The-Beginning）详解
 *  1. SATB是维持并发GC的一种手段。G1并发的基础就是SATB。SATB可以理解成在GC开始之前对堆内存里的对象做一次快照，此时活的对象就认为是
 *      活的，从而形成一个对象图。
 *  2. 在GC收集的时候，新生代的对象也认为是活的对象，除此之外其它不可达的对象都认为是垃圾对象。
 *  3. 如何找到在GC过程中分配的对象呢？每个region记录着两个 top-at-mark-start（TAMS）指针，分别为 prevTAMS 和 nextTAMS。在
 *      TAMS以上的对象就是新分配的，因而被视为隐式marked。
 *  4. 通过这种方式我们就找到了在GC过程中新分配的对象，并把谢谢对象认为是活的对象。
 *  5. mark的过程就是遍历heap标记live object的过程，采用的是三色标记算法，这三种颜色为 white（表示还未访问到的对象）、gray（访问到但
 *      是它用到的引用还没有完全扫描）、black（访问到而且其用到的引用已经完全扫描完）
 *  6. 整个三色标记算法就是从 GC roots出发遍历heap，针对可达对象先标记white为gray，然后再标记gray为black；遍历完成之后所有可达对象都是
 *      black的，所有white都是可以回收的。
 *  7. SATB仅仅对于在marking开始阶段进行 “snapshot”（marked all reachable at mark start），但是 concurrent 的时候并发修改可能造成对象漏标记。
 *      （1）.对black新引用了一个white对象，然后又从gray对象中删除了对该white对象的引用，这样会造成了该white对象漏标记。
 *      （2）.对black新引用了一个white对象，然后从gray对象删了一个引用该white对象的white对象，这样也会造成该white对象漏标记。
 *     （3）.对black新引用了一个刚new出来的white对象，没有其它gray对象引用该white对象，这样也会造成该white对象漏标记。
 *     （4）.漏标的情况只会发生在白色对象中，且满足以下任意一个条件：
 *          (1).并发标记的时候，应用线程给一个黑色对象的引用类型字段赋值了该白色对象；
 *          (2).并发标记的时候，应用线程删除所有灰色对象到该白色对象的引用。
 *     （5）.针对于（4）中两种漏标情况解决方案：
 *          (1).针对于（4）-(1): 利用写后屏障（post-write barrier），记录所有新增的引用关系，然后根据这些用用关系为根重新扫描一遍。
 *          (2).针对于（4）-(2): 利用写前屏障（post-write barrier），将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根重新扫描一遍。
 *  11. 对于三色算法在concurrent的时候可能产生的漏标记问题，SATB在marking阶段中，对于从gray对象移除的目标引用对象标记为gray，对于black引用的新产生
 *          的对象标记为black；由于是在开始的时候进行 snapshot，因而可能存在浮动垃圾（floating garbage）。
 *  12. 误标的后果是造成浮动垃圾（在接受范围内），下次GC还是可以回收的。但是漏标的后果是致命的，把本应该存活的对象给回收了，严重影响了程序的正确性。
 *  13.
 *  14.
 *
 * G1 停顿预测模型
 *  1. G1收集器土出表现出来的一点是通过一个停顿预测模型————根据用户配置的停顿时间来选择CSet的大小，从而达到用户期待的应用程序暂停时间。
 *      通过 -XX:MaxGCPauseMillis 参数来设置。这有点类似于 Parallel Scavenge收集器。
 *  2. 设置的时间越短意味着每次收集的CSet越小，导致垃圾足部积累变多，最终不得不退化成 Serial GC；停顿时间设置的越长，会导致每次都产
 *      生长时间的停顿，影响程序对外的相应时间。
 *  3.
 */

/**
 * G1 混合式回收
 *  1. G1到现在可以知道哪些老的分区可回收垃圾最多。当全局并发标记完成后，在某个时刻，就开始了Mixed GC 。这些垃圾回收被称作 ”混合式“
 *      是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。
 *  2. 混合式GC也是采用的复制清理策略，当GC完成后，会重新释放空间。
 *
 * G1分区机制
 *  1. 为老年代设置分区的目的是老年代里有的分区垃圾多，有的分区垃圾少，这样在回收的时候可以专注于收集垃圾多的分区，这也是G1名称的由来。
 *  2. 不过这个机制并不适合新生代垃圾收集，因为新生代的垃圾收集算法是复制算法，但是新生代也使用了分区机制主要是因为便于代的大小调整
 *
 * G1的收集模式
 *  1. Young GC： 收集年轻代里所有的Region
 *  2. Mixed GC： 收集年轻代的所有的Region + 全局并发标记阶段选出来的收益高的Region
 *  3. 无论是Young GC 还是 Mixed GC都只是并发拷贝的阶段
 *  4. 分代模式下选择CSet有两种子模式，分别对应Young GC和 Mixed GC:
 *      （1）.Young GC: CSet就是所有年轻代里面的Region；
 *      （2）.Mixed GC: CSet是所有年轻代里的Region加上在全局并发标记阶段标记出来的收益高的Region。
 *  5. G1的运行过程：会在Young GC和Mixed GC之间不断的切换运行，同时定期的做全局并发标记，实在赶不上对象创建速度的情况下使用 Full GC（Serial GC）
 *  6. 初始标记是在Young GC上执行的，在进行全局并发标记的时候不会做Mixed GC，在做Mixed GC的时候也不会启动初始标记阶段。
 *  7. 当Mixed GC赶不上对象产生的速度的时候就会退化成Full GC，这一点是需要重点调优的地方。
 */

/**
 * G1 最佳实践
 *  1. 不断调优暂停时间指标： 通过 -XX:MaxGCPauseMillis=x 可以设置启动应用程序暂停的时间，G1在运行的时候会根据这个参数选这CSet来满足响应时间的设置。
 *      一般情况下这个值到100ms或者200ms都是可以的（不同情况下会不一样），但如果设置成50ms就不合理了。暂停时间设置的太短，就会导致G1跟不上垃圾产生的
 *      速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。
 *  2. 不要设置新生代和老年大的大小
 *      （1）.G1收集器在运行的时候会调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到收集器设置的暂停时间目标。
 *      （2）.设置新生代大小相当于放弃了G1做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交个G1自己去分配各个代的大小即可。
 *  3. 关注Evacuation Failure： Evacuation Failure 类似于CMS里面的晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，浴室不得不退化成Full GC来做一次
 *      全局范围内的垃圾收集。
 *  4.
 *
 *
 */
public class G1GCTest1 {

    public static void main(String[] args) {

    }
}
