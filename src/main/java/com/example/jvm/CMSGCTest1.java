package com.example.jvm;

/**
 * 枚举根节点
 * 1.当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。
 * 在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。
 * 安全点（SafePoint）
 * 1. 在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举，但一个很现实的问题随之而来: 可能导致引用关系的变化，或者说 OopMap 内容变化的指令非常多，
 * 如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本会变得更高。
 * 2. 实际上，HotSpot 并没有为每条指令都生成 OopMap，而只是在 “特定的位置” 记录了这些信息， 这些位置称为安全点，即程序执行时并非在所有地方
 * 都能停顿下来开始GC，只有在到达安全点时才能暂停。
 * 3. 安全点的选定既不能太少，以至于让GC等待是将太长，也不能过于频繁以至于过分增大运行时的负载。所以安全点的选定基本上是以 ”是否具有让程序长时间执行的特征“
 * 为标准进行选定的。因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而长时间运行， “长时间运行” 的最明显特征就是指令序列复用，
 * 例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点。
 * 4. 对于安全点，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都执行到最近的安全点上再停顿下来。于是产生了
 * 抢断式中断和 主动式中断。
 * 5. 抢断式中断（Preemptive Suspension）： 它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就
 * 恢复线程，让它执行到安全点上。
 * 6. 主动式中断（Voluntary Suspension）： 当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为
 * true 时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。
 * 注： 现在几乎没有虚拟机采用抢占式中断来暂停线程从而相应GC事件。
 * 安全区域（SafeRegin）
 * 1. 在使用安全点似乎已经完美的解决了如何进入GC的问题，但实际上情况去不一定。安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点。但
 * 如果程序在 “不执行” 的时间呢？ 所谓程序不执行就是没有分配CPU时间，不如处于 sleep状态或者 block 状态，这个时候程序无法响应 JVM 中断请求， JVM
 * 也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要安全区域来解决了。
 * 2. 在线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，在这段时间里 JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，
 * 它要检查系统是否已经完成了根节点（或是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直接收到可以离开安全区域的信号为止。
 */

/**
 * CMS收集器
 *  1. CMS（Concurrent Mark Sweep） 收集器，以获取最短回收停顿时间为目标，多数应用于互联网网站或者B/S系统的服务器端上。
 *  2. CMS是基于 “标记-清除” 算法实现的，整个过程分为四个步骤（初始标记、重新标记这两个步骤是需要 “STW”的）：
 *      （1）.初始标记（CMS initial mark）: 初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快。
 *      （2）.并发标记（CMS concurrent mark）: 并发标记阶段就是进行 GC Roots Tracing 的过程。
 *      （3）.重新标记（CMS remark）: 重新标记阶段则是为了修正并发标记期间因用户线程继续执行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比
 *                                      初始标记极端稍长一些，但远比并发标记的时间短。
 *      （4）.并发清除（CMS concurrent sweep）: 并发清除被标记的对象。
 *  3. CMS收集器在整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS收集器的内存回收过程是与用户线程一起并发执行的。
 *  4. 优点： 并发收集、低停顿，Oracle 公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）
 *  5. 缺点：
 *      （1）.CMS收集器对CPU资源非常敏感；
 *      （2）.CMS收集器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致另一次Full GC的产生。如果在应用中老年代增长不是太快，可以适当调高参数
 *              -XX:CMSInitiatingOccupancyFraction 的值来提高出发百分比，以便降低内存回收次数从而获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要时，
 *              虚拟机将启用后备预案：零食启用 Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就长了。所以说参数 -XX:CMSInitiatingOccupancyFraction
 *              设置的时间太高很容易导致大量的 “Concurrent Mode Failure” 失败，性能反而降低。
 *      （3）.收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前
 *              对象，不得不提前进行一次Full GC。CMS收集器提供一个： XX+UseCMSCompactATFullCollection 开关参数（默认是开启的），用于在CMS收集器顶不住要进行 Full GC
 *              时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。
 *      （4）.对于堆比较大的应用，GC的时间难以预估。
 * CMS收集器手机步骤
 *  1. 初始标记阶段（initial mark）： 此阶段会造成STW，这个阶段的目标是标记那些直接被GC root引用或者被年轻代存活对象所引用的所有对象。
 *  2. 并发标记阶段（concurrent mark）： 这个阶段Garbage Collector 会遍历老年代，然后标记所有存活的对象，它会根据上个阶段找到GC Roots遍历查找。它会与用户的应用程序并发
 *                                      运行。并不是老年代所有的存活对象都会标记，因为在标记期间用户的程序可能会改变一些引用。
 *  3. 并发预清理阶段（concurrent preclean）： 这个阶段与用户线程并发执行，并不会停止应用线程。在并发运行的过程中，一些对象的引用可能会发生变化，但是这种情况发生时，JVM会将
 *                                              包含这个对象的区域（card）标记为Dirty，也就是 Card Marking。在此阶段那些能从Dirty对象到达的对象也会被标记，这个标记做完
 *                                              之后，dirty card 标记就会被清除。
 *  4. 并发可失败的预清理阶段（concurrent abortable preclean）： 这个阶段是为了尽量承担STW中最终标记阶段的工作。这个阶段持续时间依赖于很多因素，由于这个阶段是在重复做很多
 *                                                              相同的工作，直接满足一些条件(比如: 重复迭代的次数，完成的工作量或者时钟时间等)
 *  5. 最终重标记阶段（final remark）： 此阶段会造成STW。这个阶段的目标是标记老年代所有的存活对象，由于之前的阶段是并发执行的，GC线程可能跟不上应用程序的变化，为了完成标记
 *                                      老年代多有存活对象的目标，STW就非常有必要了。通常CMS的 final remark 阶段会在年轻代尽可能干净的时候运行，目的就是为了减少连续STW
 *                                      发生的可能性(年轻代存活对象过多的话，也会导致老年代设计的存活对象会很多)。这个阶段会比前面的几个阶段更复杂一些。
 *  6. 并发清除阶段（concurrent sweep）： 此阶段是清除那些不再使用的对象，回收它们的占用空间为将来使用。
 *  7. 并发整理阶段（concurrent reset）： 此阶段会重设CMS内部的数据结构，为下次的GC准备。
 *
 *
 * 空间分配担保
 *  在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看
 *  HandlerPromotionFailure设置是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，将尝试着进行一次
 *  Monitor GC，尽管这次GC是有风险的。如果小于，或者HandlerPromotionFailure设置不允许冒险（新生代使用复制收集算法，但是为了内存利用率。只使用其中一个Survivor空间
 *  来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况(最极端的情况是内存回收之后，新生代中所有的对象都存活)，就需要老年代进行分配担保，把Survivor无法
 *  容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象存活下来在实际完成内存回收之前是无法明确知道的，
 *  所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。取平均值进行比较其实
 *  仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现HandlerPromotionFailure失败，那就只好在失败
 *  后重新发起一次FULL GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是将HandlerPromotionFailure开关打开，避免Full GC过于频繁。），那这时也要改为进行一次Full GC了。
 */

/**
 * -verbose:gc
 * -Xms20m
 * -Xmx20m
 * -Xmn10m
 * -XX:+PrintGCDetails
 * -XX:SurvivorRatio=8
 * -XX:+UseConcMarkSweepGC
 */
public class CMSGCTest1 {
    public static void main(String[] args) {
        int size = 1024 * 1024;
        byte[] bytes1 = new byte[4 * size];
        System.out.println("111111111111111");
        byte[] bytes2 = new byte[4 * size];
        System.out.println("222222222222222");
        byte[] bytes3 = new byte[4 * size];
        System.out.println("333333333333333");
        byte[] bytes4 = new byte[2 * size];
        System.out.println("444444444444444");
    }
}
